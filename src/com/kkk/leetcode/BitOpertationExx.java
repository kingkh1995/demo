package com.kkk.leetcode;

/**
 * 二进制位运算
 *
 * @author KaiKoo
 */
public class BitOpertationExx {

  // ===============================================================================================
  /** 基础题 */

  // ===============================================================================================
  /** 拔高题 */

  // n+1大小的数组，元素在[1,n]之间，只有一个元素重复出现了多次 求出该元素
  public static int findDuplicate(int[] nums) {
    int position = 0;
    int n = nums.length - 1;
    // 先判断二进制下有多少位
    while (n != 0) {
      n >>= 1;
      position++;
    }
    n = nums.length - 1;
    int t = 1;
    int ans = 0;
    for (int i = 0; i < position; i++) {
      // 统计当前位下1-n加起来总计有多个1
      int count = 0;
      for (int j = 1; j <= n; j++) {
        if ((j & t) == t) {
          count++;
        }
      }
      // 统计数组中所有元素当前位1的个数 如果超过count 则表示重复的数当前位为1
      // 因为1-n所有的元素并不是都存在，即用重复元素替换了缺失的元素去进行统计，但是结论仍然成立
      // 1、重复元素当前位为1、被替换的元素也为1即完美替换无影响、不为1则会使1的总数增加，判定重复元素当前位为1，故不影响。
      // 2、重复元素当前位为0、被替换的元素也为0即完美替换无影响、不为0则会使1的总数减小，即判断重复元素当前位不为1，不影响。
      for (int j : nums) {
        if ((j & t) == t) {
          count--;
        }
        // 如果超过了 表示重复元素
        if (count < 0) {
          ans += t;
          break;
        }
      }
      t <<= 1;
    }
    return ans;
  }
}
